# Задание 1

Реализуйте бинарное дерево (**не BST**) с поддержкой следующих операций:
1. Поиск наименьшего общего предка (LCA) для двух узлов.
**Узлы не имеют ссылок на родителей.**
Решение должно работать за `O(n)`, где `n` — количество узлов.
2. Зеркальное отображение дерева (инвертирование левого и правого поддеревьев для каждого узла).
**Требуется** in-place модификация исходного дерева.
3. Подсчёт расстояния между двумя узлами (количество ребер на пути от одного узла к другому).
Решение должно использовать LCA для оптимизации.

Для наглядности можно использовать метод вывода дерева на экран:
```
def print_tree(node, prefix="", is_left=True):
    """Красивый вывод бинарного дерева в консоль."""
    if node is not None:
        print_tree(node.right, prefix + ("│   " if is_left else "    "), False)
        print(prefix + ("└── " if is_left else "┌── ") + str(node.val))
        print_tree(node.left, prefix + ("    " if is_left else "│   "), True)
```

# Задание 2

Дополнить задание 2 из ЛР 7 пирамидальной сортировкой.

Сравнить результаты.

# Задание 3

Дано `K` отсортированных массивов. Объедините их в один отсортированный массив, используя пирамидальную сортировку.

Реализуйте min-heap для выбора минимального элемента из текущих вершин всех K массивов.

Оптимизируйте алгоритм для работы за `O(N log K)`, где `N` — общее количество элементов.
