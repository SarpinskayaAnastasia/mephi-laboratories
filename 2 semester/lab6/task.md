# 1 задача

Реализуйте алгоритм сортировки слиянием для односвязного списка. Алгоритм должен работать без преобразования списка в массив и обратно.

Требования:

- Реализовать функцию `merge_sort_linked_list(head)`, которая принимает голову списка и возвращает отсортированный список.
- Реализовать функцию `merge_lists(left, right)` для объединения двух отсортированных списков.

## Пример ввода:

### Создание односвязного списка

```python
class LinkedList:
    def append(self, item: int):
        pass


linked_list = LinkedList()
linked_list.append(38)
linked_list.append(27)
linked_list.append(43)
linked_list.append(3)
linked_list.append(9)
linked_list.append(82)
linked_list.append(10)
```

### Сортировка

`sorted_head = merge_sort_linked_list(linked_list.head)`

## Пример вывода:

Отсортированный список: `3 -> 9 -> 10 -> 27 -> 38 -> 43 -> 82`

# 2 задача

Напишите программу для сравнения времени выполнения трёх алгоритмов сортировки:

- Сортировка слиянием. 
- Быстрая сортировка.
- Встроенная функция Python sorted().

Заполнение массива случайными числами, размер массива `10 ** 3`, `10 ** 4`, `10 ** 5`, `10 ** 6`. Проанализируйте полученные результаты.

После проведения начального анализа, реализуйте оптимизированные версии алгоритмов сортировки слиянием и быстрой сортировки и повторите повторный анализ.

## Пример вывода:

```
Размер массива: <размер>
---------------------------------
Метод                       | Время (мс)
---------------------------------
Сортировка слиянием         | XXX.XX
Быстрая сортировка          | XXX.XX
Python sorted()             | XXX.XX
---------------------------------
```

# 3 задача

Реализуйте модификацию алгоритма сортировки слиянием, которая минимизирует количество сравнений элементов. Для этого:

1. Используйте стратегию "естественного слияния" — объединяйте уже упорядоченные подмассивы (возникающие в исходном массиве) вместо рекурсивного разделения.

2. Подсчитайте количество сравнений для случайных, упорядоченных и обратно упорядоченных массивов.

Требования:

- Реализовать функцию natural_merge_sort(array).
- Сравнить количество сравнений с классической сортировкой слиянием и быстрой сортировкой для массивов размером 10³–10⁴ элементов.

## Пример вывода:

```
Тип массива | Natural Merge | Classic Merge | Quick Sort |
Случайный   |   XXX         |   XXX         |   XXX      |
Отсортир.   |   XXX         |   XXX         |   XXX      |
Обратный    |   XXX         |   XXX         |   XXX      |
```